# 字符串

## 一.String类

+ **String对象是不可变的**
+ String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容，而最初的String对象丝毫未动

#### 1.String对象的比较

在比较String对象的时候，不能单纯的用==来比较两个字符串的大小，**这样比较的是他们的堆地址** ，在比较两个字符串的时候，要用到String类提供的equals方法，**它的返回值是boolean类型** ；
下面看一段示例：

```java
	String str1 = "i love you";
	String str2 = "i hate you";
	System.out.println(str1.equals(str2));  //equals函数的返回值为Boolean类型
```

这段代码的输出结果为false；

+ **小知识：在今后的开发中，如果要判断用户输入的字符串是否等同于特定字符串，一定要将特定字符串写在前面，避免用户输入的字符串为空导致出错；（看如下例子）**

  ```java
          String str2 = null;
          System.out.println(str2.equals("hello"));
  ```

  会出现以下错误：**Exception in thread "main" java.lang.NullPointerException**

  

####  2.重载“+”与StringBuilder

因为字符串（String对象）是不可变的，所以在对字符串进行拼接时，将会产生大量垃圾空间（虽然java系统会在底层自动优化），带来一定的效率问题；

**在进行字符串的拼接时，编译器其实自主使用了StringBuilder类，创建一个StringBuilder对象，用以构造最终的String，并用每个字符串调用一次StringBuilder的append（）方法。最后调用toString方法来生成结果。**

这样也许你会觉得反正编译器会自主优化成StringBuilder对象，但学过汇编的可以进入到底层源码中查看，会发现尽管这样，当使用拼接次数过大时，还是会产生效率问题；



#### 3.String的匿名对象

+ 在任何语言的底层，都不会提供有直接的字符串类型。现在所谓的字符串只是高级语言提供给用户方便开发的支持而已。**在java中，所有使用 “ ” 定义的内容本质上来讲都是String的匿名对象。**
+ 例如：String  str  =  “ i love  you  ” ；这条语句中的 “ i love  you  ” 就是String的一个匿名对象，我们可以通过“ i love  you  ” 加点（.）来调用String类的各种方法，**这进一步说明了“ i love  you  ”是一个对象；**



#### 4.String的两种实例化格式以及他们的区别

String类有两种实例化格式，如下所示：

```java
        String str1 = "hello";   //直接实例化   方法一
        String str2 = new String("hello");   //方法二
```

我们来看方法一的特点：

```java
String str1 = "hello";
String str2 = "hello";
String str3 = "hello";
System.out.println(str1 == str2);
System.out.println(str2 == str3);
System.out.println(str1 == str3);
```

这段代码将会输出：
true
true
true

+ **这说明了直接实例化的字符串一样时，他们都在同一块堆内存中保存**，如下图：

![1549801471448](C:\Users\Laptop\AppData\Local\Temp\1549801471448.png)

+ **String类的设计使用了共享设计模式**
+ **在JVM底层实际上会自动维护一个对象池（字符串对象池），如果现在采用了直接赋值的模式进行String类的对象 实例化操作，那么该实例化对象（字符串内容）将自动保存到这个对象池之中。如果下次继续使用直接赋值的模式 声明String类对象，此时对象池之中如若有指定内容，将直接进行引用；如若没有，则开辟新的字符串对象而后将 其保存在对象池之中以供下次使用**
  **所谓的对象池就是一个对象数组（目的就是减少开销）；**



**下面看看方法二：** 

```java
String str = new String("hello");
```

这条语句在内存中分布如下图：
![1549802542459](C:\Users\Laptop\AppData\Local\Temp\1549802542459.png)

通过如上图可见，通过构造方法实例化就会产生两块堆内存空间，并且一块为垃圾空间（**没有引用指向的堆空间为垃圾空间** ）。

观察下面一段代码：（字符串共享问题）

```java
        String str1 = "hello";
        String str2 = new String("hello");   //该字符串常量没有保存到对象池中
        System.out.println(str1 == str2);   //输出false
```

代码输出：false

**为了解决这一问题，在String类中提供有方法入池操作：public String  intern（）；** 
如下代码：

```java
        //入池操作
        String str1 = new String("hello").intern();
        //str1 = str1.intern();   //或者这样写，记住intern()方法有返回值哟，为String；
        String str2 = "hello";
        System.out.println(str1 == str2);
```

注意：intern()方法返回值为String，所以注释那一句不要写成：str1 . intern( ) ;



#### 5.字符与字符串

+ 字符串就是一个字符数组，所以String类中有转换为字符数组的方法；

|      |                       方法名称                        | 类型 |                描述                 |
| :--: | :---------------------------------------------------: | :--: | :---------------------------------: |
|  1   |            public String（char value[] ）             | 构造 |   将字符数组中所有内容变为字符串    |
|  2   | public String （char value[]，int offset，int count） | 构造 |  将部分字符数组中的内容变为字符串   |
|  3   |            public char charAt（int index）            | 普通 | 取得指定索引位置的字符，索引从0开始 |
|  4   |             public char[] toCharArray（）             | 普通 |      将字符串变为字符数组返回       |

**看下面一段练习代码，输出答案已在注释上** ：

```java
        //字符串--->数组
        String str1 = "i love you";
        char[] arr = str1.toCharArray();
        for(char x:arr){    //foreach语句
            System.out.print(x+"、");    //i、 、l、o、v、e、 、y、o、u、
        }
        //数组--->字符串
        System.out.println(new String(arr)); //i love you
        System.out.println(new String(arr,2,5)); //love
```

